<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	
</body>
</html>
<script src="js/matter.js"></script>
<script type="text/javascript" src="js/pixi.min.js"></script>
<script>
	// module aliases
	var Engine = Matter.Engine,
	    Render = Matter.RenderPixi,
	    World = Matter.World,
	    Body = Matter.Body,
	    Runner = Matter.Runner,
	    Constraint = Matter.Constraint,
	    Composites = Matter.Composites,
	    Bodies = Matter.Bodies;

	// create an engine
	var engine = Engine.create();
	// create an runner
	var runner = Runner.create();

	// create a renderer
	var render = Render.create({
	    element: document.body,
	    engine: engine
	});

	var rim = Matter.Bodies.circle(400, 300, 30);
	var rim1 = Matter.Bodies.circle(200, 300, 30);

	Matter.Body.setDensity(rim1,0.001);
	Matter.Body.setDensity(rim,0.001);

	World.add(engine.world, [
		rim,
		rim1,
		Constraint.create({ pointA: { x: 400, y: 80}, bodyB: rim,pointB: { x: 0, y: 0 }, stiffness:1}),
		Constraint.create({ pointA: { x: 200, y: 300 }, bodyB: rim,pointB: { x: 0, y: 0 }, stiffness:0.1 }),
		Constraint.create({ pointA: { x: 600, y: 300 }, bodyB: rim,pointB: { x: 0, y: 0 }, stiffness:0.1 }),
		Constraint.create({ pointA: { x: 200, y: 80}, bodyB: rim1,pointB: { x: 0, y: 0 }, stiffness:1}),
		Constraint.create({ pointA: { x: 0, y: 300 }, bodyB: rim1,pointB: { x: 0, y: 0 }, stiffness:1}),
		Constraint.create({ pointA: { x: 400, y: 300 }, bodyB: rim1,pointB: { x: 0, y: 0 }, stiffness:1 })
		// Constraint.create({ bodyB: rim1,bodyA:rim,pointA: { x: 0, y: 30 },pointB: { x: 0, y: -30 }, stiffness:1 }),
		// Constraint.create({ bodyB: rim1,bodyA:rim,pointA: { x: 0, y: -30 },pointB: { x: 0, y: 30 }, stiffness:1 }),
		// Constraint.create({ bodyB: rim1,bodyA:rim,pointA: { x: 0, y: 30 },pointB: { x: 0, y: 30 }, stiffness:1 }),
		// Constraint.create({ bodyB: rim1,bodyA:rim,pointA: { x: 0, y: -30 },pointB: { x: 0, y: -30 }, stiffness:1 }),
		// Constraint.create({ bodyB: rim1,bodyA:rim,pointA: { x: 30, y: 0 },pointB: { x: -30, y: 0 }, stiffness:1 })
		]);

    // var world = engine.world,
    //     group = Body.nextGroup(true);
    
    // var bridge = Composites.stack(150, 300, 9, 1, 10, 10, function(x, y) {
    //     return Bodies.rectangle(x, y, 50, 20, { collisionFilter: { group: group } });
    // });
    
    // Composites.chain(bridge, 0.5, 0, -0.5, 0, { stiffness: 0.9 });
    
    // var stack = Composites.stack(200, 40, 6, 3, 0, 0, function(x, y) {
    //     return Bodies.polygon(x, y, Math.round(5), 30);
    // });

    // World.add(world, [
    //     bridge,
    //     Bodies.rectangle(80, 440, 120, 280, { isStatic: true }),
    //     Bodies.rectangle(720, 440, 120, 280, { isStatic: true }),
    //     Constraint.create({ pointA: { x: 140, y: 300 }, bodyB: bridge.bodies[0], pointB: { x: -25, y: 0 } }),
    //     Constraint.create({ pointA: { x: 660, y: 300 }, bodyB: bridge.bodies[8], pointB: { x: 25, y: 0 } }),
    //     stack
    // ]);
	// create two boxes and a ground
	var boxA = Bodies.circle(200, 50, 50);
	// Matter.Body.setVelocity(boxA,Matter.Vector.create(10, -10));
	// boxA.angle=15;
	var boxB = Bodies.rectangle(400, 50, 80, 80);
	var ground = Bodies.rectangle(400, 610, 810, 60, { isStatic: true });

	// add all of the bodies to the world
	World.add(engine.world, [boxA,  ground]);

	// run the engine
	// Engine.run(engine);
	Runner.run(runner,engine);

	Matter.Events.on(runner,'beforeUpdate',function(){
		// console.log(1);
		// console.log(boxA.speed);
	});

	// run the renderer
	

	var renderOptions = render.options;
        renderOptions.wireframes = true;
        renderOptions.hasBounds = true;
        renderOptions.showDebug = true;
        renderOptions.showBroadphase = true;
        renderOptions.showBounds = true;
        renderOptions.showVelocity = true;
        renderOptions.showCollisions = true;
        renderOptions.showAxes = true;
        renderOptions.showPositions = true;
        renderOptions.showAngleIndicator = true;
        renderOptions.showIds = true;
        renderOptions.showShadows = true;
        renderOptions.showVertexNumbers = true;
        renderOptions.showConvexHulls = true;
        renderOptions.showInternalEdges = true;
        renderOptions.showSeparations = true;
        renderOptions.background = '#fff';
    Render.run(render);

	// Matter.Events.on(render, "beforeRender", function(){
	// 	// console.log(1);
	// });
</script>